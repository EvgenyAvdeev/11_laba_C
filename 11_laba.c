#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define M 100
#define N 10000



typedef struct {
    char fio[30];
    char name[30];
    char redaction[30];
    int year;
    int page;
}book_info;

int error() {

    puts(":--:::::::-:::--:---:::::--:--~-:.::::-------:~.:::-::-::-:----::.........:.....  @@@##@##@#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@.     .##]#)[@@@##(<^~~><[@ ");
    puts(".::.::::.::.:::::-:::::::-.:.::::::::.:....::::.::::.:--::::::::.:...............  #@@@@@####@###@@@#@@@@#@###@@@@#@@#@@##@@@@@@@@@@@@@@@@@@{{@@@^    .@@@@@(*.  :@@@@@@@@@@])>= ");
    puts(":::::::.::::::::::::::::::::::::::::-::::::::::::::::::::::::--:.................. @@@@@#@@@@@@@@@#@###@#{##@##@########@##@@@@@@@@@@@@####{#@]   .[@@@<-.  .-(@@@@[}#@#@#[}{#@@.");
    puts("...:..:::.::.::..::..::..::...:..:.:..:::.::.::...:...:.::::.:::.................. @@@###@#@@@@@@@#@@@###@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@[}=  :#@@@{]]#@@@@@@@#{[](<)>))(((]]} ");
    puts(":::::..::.::..-..::..:...:::::-.:.:-:.:::.:...::.::...::..:::..................... #@#{########{#########@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@[}}}#[)<((((()(((<^^>>>^*-~+^ ");
    puts("-:.::.:-..-:..:..--::-:..-::..-:-..:...-::::::-::--..----::-:.:................... ]@###@#########@#@@#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@)}##{{##[()^<(><)[)^^^>^^*****^*** ");
    puts("....:.:..................:........................:.........:.:................... >@#{#}{{{{####{####{@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@)~[{}>^><]{}(<()())()>^><^><<^^<)<>< ");
    puts("::....::...:...:.:..........:.::.:...........:....::..::......:................... -@{{#@##{##@@#####@{#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@:+@@@@@{]>))<()}@@@]>^^^>))<>>><>*=~- ");
    puts("..::-...::.::.::.:.-::::.::..::..:::::.:::::..:::.::.:..::.::..................... .@}{}}{{{{{#{{###{#{#@@@@@}##@@@#@@@@@@@@@@@@@@@@@@@@@@~@@#{{{]]((}<^*>)^>}[##>^)][(<*+*><()* ");
    puts(":......:.........::.:..:.:....:......:..::.::......::.::....:.....................  @*++^*+**><[{{{{###{@@@@#(##@@@}@@@@@@@@@@@@@@@@@@@@@.@@@@@[^*><+((<+*<)<^.-@#}{])))][[[(}}) ");
    puts(".....:...:..::.:.......:..:..::......:...:..:...::.:......:.::....................  @@@@@@@@@@@]}}###{#}{@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@.[#[(){@@@)>^<^*^[}>>)+-~^((<^^*^<)(>+*^ ");
    puts("..............................:.......................:......:....................  @@@@@@@@@@@}(}{{}{#[[@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@)~(}{#{: >@@@<+<)**()<>([[<>)[}}]()))>^** ");
    puts(".::......................:.::...:..:..:.......:..:....:...........................  @@@@@@@@@@@]]{{{#}[}[@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ >@@@@@@@:.*##)*)(++<}}(<<<)<>*^<[}}(<*=* ");
    puts("....::......:...::.....:.:..............:..::......:........::....................  @]][}[@@@@@))[{}{}}[(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@#()^*>[}}(}{{(()](<^>>>*++ ");
    puts(":........................:::.......:..........:.................................... @##{#[@@@@@^(}[[}[#])@@@@@@@@@@@@@@@@@@@@@@@#@@@@@@@@@@@@@@@@@@@##@@}##}<<((((++>>)(}{)+===+ ");
    puts("..............................::..........:........................................ @#{##(@@@@@^<][][[}()@@@@@@@@@@@@@@@@@@@@@@@{@@@#@@@@##()(}@@@@@@#<)(@@@@###{[)(#@]. .*{@@@@ ");
    puts("................................................................................... @]}}}^@@@@@><][[}}{[(@@@@@@@@@@@@@@@@@@@@#@@{@@@<#@@@@@}<<](([#@@@@>=<}}{@@#}()))[@#(:       ");
    puts("........                 ..       ....        ..        ........................... @[{]}(@@@@@>)]}[[]([(@@@@@@@@@@@@@@@@@@@@[@@@(@<[@@@@@@@@@@@@@{@@@@#(}[]}#@@@@@@@@@@@@@@@@@@ ");
    puts("........ @@@@@@@  @@@@@@    @@@@@      @@@@@@    @@@@@[  .......................... @##]]^@@@<@]<([][]][)@@@@@@@@@@@@@@@@@@@@@@@@ .@@@@@@@@@@@@@@@@@@@@[.=+~=)]{@@@@@@@@@@@@@@@@@");
    puts("........ @@       @@   @@   @    @@  @@.    @@   @#   @@ .......................... @(<)(+@@@ @[>[][}[[(<@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@[{@@})<<>@@@@@@}:::...~}#@@@######{@@@@@@@");
    puts("........ @@       @@   @@   @    @# .@   ..  @@  @=   @@ .......................... @)[)]^@@@^@)<][[}[[[(@@@@@@@@@@@@@@@@@@@@@@@@@(]([#>..:~**<{#@@@}^->](*^>(@@@@@@@#]<=:...+)]+");
    puts("........ @@@@@@.  @@@@@.    @@@@@   -@  .... @@  @@@@@   ...........      ......... @[}]}<@@@^@)<](]]([]<@@@@@@@@@#)@@@@@@@@@@@@@@{#}]@@@@@@##@@@@@*.~~..=>>*:.+@@@@@@@@@@@]*=-: ");
    puts("........ @@       @@   @@   @   @@   @#      @#  @~  .@. .........   ^#)~.       .. @}(([<@@@{@*<@@@{}][<@@@@@@<@]{*@ @@@@@@@@@{}@@@@@{<**^<[#@@@^=:-=..-*>^^+*=^@@@@@@@@)<(}[[#~");
    puts("........ @@@@@@#  @@   #@@ .@#   @@  ^@@@}@@@@   @@   @@ ......... )@^:..>}#@@}<  . @@]([<@@@#@>#^ @##[]<@@@@@@.@@@{@ @@@@@@@@@@{@#@@}])<^*(@@@]^+><>*<)>*(<>^*^#{{#@@@@@@@@]]##^");
    puts("........       .     .         .        .}-    .    .    ......... @@-.*>==<(])^.   @@@@@[@@@@@*@).  @}])@@@@@@*@@@@@.@@@@@@@@@@#@@{)<<>^]@@@^-.=*[}<^>(}(>^><*:#@#<><]{{#@@@@@@@");
    puts("..........     ........................     ...................... =@@}+:......:^}#:    @@@@@#@*(@@@@@{)^@@@@@@.@@@@@.@@@@@@@@@@##}()<<[@@@@@(-.=.  :+*^<)(<~:~..]@@*  :>)=.. ...");
    puts("..................................................................  ~@@@@#)>^+==+~++==-   -@@@@#<<((([](^@@@@@@@@@@@@<@@@@@@@@@@@#}]([#@@@@@@@[=:.    :><<(#{..:..)@@@)   ....   ");
    puts("...................................................................  .^@@@@@@#}[[(<^~::-=.    >@@@@{][([<@@@@@@@@@@@@@@@@@@@@@@@##{}@@@@@@@@@@@@@(([>. .=)^#@@..::.*{#@@@>..:=<[ ");
    puts("....................................................................    .*{@@@@#[^=*)>*-..:<(.    @@@@#}<@@@@ @@@@@@@@@@@@@@@@@###@@@@@@@@@@@@@@@@@@@@@+.::(@@@*--~:-^)<[@@@@@@@ ");
    puts("......................................................................      -<@@@#]>>*^)+.  ~<*~.    @@@{#@@@ @@@@@@@@@@@@  @@@#@@@@@@@@@@@@@@@@@@@@@@@@@[}<#@@@*+*+:=((^=+>*~-- ");
    puts("...........................................................................   .=#@@@@#([@#[^...~^]#}.  :@@@@@ @@@@@@@@@@@@@@@@@@@@@@@}](][#[=..   .^@@@@@@@@){@#<*=^*==*#{<>((>* ");
    puts("......................................................:......................     *@@@@@@@@[[[)=. .~)]-   @@@@@@@@@@@@@@@@@@@@#@@@@@@#[([#]{@@@=.--.  *]>.:..]@#)*:::=^-)@@[{}{] ");
    puts("..............................:...............:.......:.......................    {(~..:=<(}#@@@@@^. .+##.   *@@@@@@@@@@@@@@@@#@@@@@@@@@{>.*{@@>>)>^=:.......}#[([[]())>+^{#{(([.");
    puts("::::..::.::..:-..:::.:...--:::-::::::.::......::::.:..::....................   .@#>-.....::+^^>^*=:~=-.          >@@@@@@@@@@@@@@@@@@@@@@@@].~~..>]))<>^^)>^+-[#}<>><)]]]]^*)[]}[-");
    puts(":.:::.:-:::::.::.--..:.:.-::..:-:.....:::::::::..:.:.:--.::::-.:.......... ..~@@@[^~-.:==:::.:~<)##}}##@@@@@@@@{   *@@@@@@@@@@@@@@@@@@@@@@@@@@@^.+]{}>>^*^))<<[(>([]((<)<])[#{#}=");
    puts(".......:..:...:..:...::..::...::......::......::..:...::...................-<@#<>*=+>)<>~.....    .:+^^=-:--~+~~+*. @@@#>  ^@@@@@@@@@@##@@@@@@@@@{<>^(}}]()))[@#>([[](<()()][}}{+");
    puts("::-::::::::::::::-:::.:.:-::::--:-:::::.:::.::-.::.::::..:::.::.:..........*#}>=~:...-=<[}])[[[[[][[<^*)]#@@@{)*=~~.=:-<@@@@@@@@@@@@#{}{}(#@@#@@@@@@#)<}##]<<}@@}([[[]][[}}##{{#+");
    puts("::::-..---:-.:--.::::--:.:::::::::::::::---::.::::--.:-:----:::.::::......+#(*:.-}@@@@@@#}{#}{}[]))><))^-.   .@}<*^<@@@@@@@@@@@@@@@@@@@}<[#@@@@^  [@@@@]*<][}{@@@#{#})()]{{[}[{#=");
    puts("::::::-:::::::::.::::::::-::::-::::::::::::-::-:::::::::::::::-..:-......+@[*-.}@}+-~**^><][(>><<>^*><[[#}](>-=*){(+<@@@@@@@@@@@@@@@@@@@@@=.-*(@@@@][@@@@@@@{(@@@#]####{{{{}}}}}~");
    puts(":::::.:::.::::::.~::.:::.-~-:.:~-:--:..:.:::::-:.:::::--:..:::-.::......~@[^*+@@..=*>*^<><<><<>***>)([{{[<=+)*==>#[<(@@@@@@@@@@@@@@@@@@@@@@@})*=~++**=~~>#@@#[@@#{]}{{##{#{##{}{+");
    puts("~--=::~--:~:::--:~-----.:~~-~-~----~-:=----:.:~-----.:-~----::-::::.....}#**<[@ .>>*=:........~^))[{###)+*^>==*>}#@}<@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#}}}{###](]}}{{{{{{}[}]][^");
    puts("---~~:~-~-----~~.~-~~----=-:::~~:---~-~~------~--~--:~~~:---::-::::::..^@@)((@@#=<<>)#@{[}#@@#}())^=::~*<]]}>-+^]}@]+@@@@@@@@@@@@@@@#{](([{#@@@@@@@@@@@@@@@#@@[<]][{}}{[[}]((]{#{");
    puts("~~-:---~:-~--~~-~=----::-+~~--==~:-~----~::---+---:-~-=~:~~~-~=~~:.-...+@@[[{@@@@(@#}((<<<<^^><)](<(>...->]##)^<][#}~#@@@@@@@@@@@@@@@##{}(>*+<}@@@@@@@@#@@@@@@{([}{####{}}[#@@@@@");
    puts("+==+~~~+++=~~-==:=+=~+=:~+==~==~~~=+~~==~~~~:-++=+=~~~===-==~----~~::::-(@{<[@@@(:*+*>><<)(<)))(({{}(<~:->##}{{(^(@[:[@#@@@@@@@@@@@@@@@@##}()(]<][[}[]]]()}@@@#@@@#{]]}[{@@@@@@@@");
    puts("~--=~~~+--=~-===~==-~~~~~+++:~*=+-~+=~==~~===~=~:~~~~~+=~~~+=~==~:-~:~~:=#@<)@@@ :^><<^>>)<*==+*^<<}{##]+-^[[}#{}@@#-#@@@@@@@@@@@@@@@@@@@@@#}]))][}}[{}}]][#@@@@@@@@@#@@@@@@@@@@@");


    exit(1);
}

void gen_str(char* word, int length) {
    const char charset[] = "abcdefghijklmnopqrstuvwxyz";
    for (int i = 0; i < length - 1; i++) {
        word[i] = charset[rand() % 26];
    }
    word[length - 1] = '\0';
}

void create_books(book_info* books, int len) {
    for (int i = 0; i < len; i++) {
        gen_str(books[i].name, 5 + rand() % 5);
        gen_str(books[i].fio, 2 + rand() % 2);
        gen_str(books[i].redaction, 5 + rand() % 10);
        books[i].year = rand() % 2024;
        books[i].page = rand() % 1000;
    }
}



void out_book(book_info info) {
    printf("FIO = %s, Title = %s, Redaction = %s, Year = %d, Pages = %d\n", info.fio, info.name, info.redaction, info.year, info.page);
}


#define var 1

#if var == 1


typedef struct {
    char word[30];
}word;

struct Node {
    int key;
    book_info data;
    struct Node* next;
};


int hash(char* str) {
    int hash = 0;
    int p = 31; // простое число

    for (int i = 0; str[i] != '\0'; i++) {
        hash = (hash * p + str[i]) % 1000000; // ограничение до 1000000
    }

    return hash;
}

struct Node* addElement(struct Node* head,int key, book_info value, unsigned int position)
{
    struct Node* new_node;

    new_node = (struct Node*)malloc(sizeof(struct Node));
    new_node->key = key;
    new_node->data = value;
    new_node->next = NULL;


    if (!head) {
        return new_node;
    }
    
    if (!position)
    {
        new_node->next = head;
        return new_node;
    }
}



void printList(struct Node* head)
{
    
    if (!head) {
        printf("List is empty\n");
    }
    while (head){
        out_book(head->data);
        head = head->next;
    }

    printf("\n");
}

void out_table(struct Node** table) {
    for (int i = 0; i < M; i++) {
        printf("Index = %d\n", i);
        printList(table[i]);
    }
}



struct Node* createNode(int key, book_info data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->key = key;
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

void add_in_hash_table(struct Node** table, struct Node* node, int key) {
    if (table[key] == NULL) {
        table[key] = node;
    }
    else {
        table[key] = addElement(table[key], node->key, node->data, 0);
    }
}

void search_in_table(struct Node** table, int hash, int key) {
    
    struct Node* head = table[key];

    while (head) {

        if (head->key == hash) {
            out_book(head->data);
        }
        head = head->next;
    }
}





int main() {

    int n;
    clock_t fTimeStart, fTimeStop;

    printf("Input numbers of records: ");
    scanf("%d", &n);

    if (n <= 0) {
        error();
    }

    book_info* books = (book_info*)malloc(sizeof(book_info) * n);
    create_books(books, n);

    int* keys = (int*)malloc(sizeof(int) * n);
    for (int i = 0; i < n; i++) {
        keys[i] = hash(books[i].fio);
    }


    struct Node* nodes[N];



    for (int i = 0; i < n; i++) {
        nodes[i] = createNode(keys[i], books[i]);
    }

    struct Node* hash_table[M];

    for (int i = 0; i < M; i++) {
        hash_table[i] = NULL;
    }

    for (int i = 0; i < n; i++) {
        int key = nodes[i]->key % M;
        add_in_hash_table(hash_table, nodes[i], key);
    }
        
    out_table(hash_table);
        
    word input;
    printf("Input FIO: ");
    scanf("%s", input.word);


    int input_hash = hash(input.word);
    int input_key = hash(input.word) % M;

    fTimeStart = clock() * 1000 / CLOCKS_PER_SEC;

    search_in_table(hash_table, input_hash, input_key);

    fTimeStop = clock() * 1000 / CLOCKS_PER_SEC;

    printf("\nReal time for finding %i(ms)\n", fTimeStop - fTimeStart);

return 0;
}
#elif var==2

typedef struct tnode {
    book_info value;       
    struct tnode* left;     
    struct tnode* right;     
}tree;


void del_n(char* str) {
    char* pn = strchr(str, '\n');
    if (pn != NULL) {
        *pn = '\0';
    }
}

tree* addtree(tree* p, book_info new) {
    int cmp;
    if (p == NULL) {
        p = (tree*)malloc(sizeof(tree));
        p->value = new;
        p->left = (p->right = NULL);
    }
    else if (strcmp(new.fio, p->value.fio) < 0) {
        p->left = addtree(p->left, new);
    }
    else {
        p->right = addtree(p->right, new);
    }
    return p;
}

void treeprint(tree* p) {
    if (p != NULL) {
        treeprint(p->left);
        out_book(p->value);
        treeprint(p->right);
    }
}

tree* search(tree* root, char* find) { 
    if ((root == NULL) || !(strcmp(root->value.fio, find))) {
        return root;
    }

    if (strcmp(root->value.fio, find) > 0) {
        return search(root->left, find); }
    else {
        return search(root->right, find);
    }
}



void searchAll(tree* root, char* find) {
    tree* cur = NULL, * tmp = root;
    int flag = 0;

    do {
        cur = search(tmp, find);
        if (!cur) { break; }
        out_book(cur->value);
        flag++;
        tmp = cur->right; 
    } while (tmp);

    if (!flag) { printf("\nNOTHING\n"); }
}






int main() {
    int n;

    clock_t fTimeStart, fTimeStop;

    printf("Input numbers of records: ");
    scanf("%d", &n);
    getchar();  
    if (n <= 0) { 
        error();
    }

    book_info* books = (book_info*)malloc(n * sizeof(book_info));  
    create_books(books, n);

    
    tree * root = NULL;


    for (int i = 0; i < n; i++) { 
        root = addtree(root, books[i]);
    }

    treeprint(root);

    printf("Input FIO: ");
    char fio[20];
    fgets(fio, 20, stdin);
    del_n(fio);


    fTimeStart = clock() * 1000 / CLOCKS_PER_SEC;

    searchAll(root, fio);
    
    fTimeStop = clock() * 1000 / CLOCKS_PER_SEC;

    printf("\nReal time for finding %i(ms)\n", fTimeStop - fTimeStart);

    return 0;
}

#endif
